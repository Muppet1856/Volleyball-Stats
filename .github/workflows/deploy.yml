name: Deploy & Update Preview Badge

on:
  push:
    branches: [ main ]
    paths-ignore: [ '**/.github/**', '**/README.md' ]
  pull_request:
    types: [ opened, synchronize ]
    paths-ignore: [ '**/.github/**', '**/README.md' ]
  workflow_dispatch:
    inputs:
      badge_label:
        description: 'Override badge label (defaults to branch/PR name or "production")'
        required: false

concurrency:
  group: deploy-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-and-badge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      WORKER_NAME: ${{ vars.WORKER_NAME }}
      BINDING_NAME: ${{ vars.BINDING_NAME }}
      USE_PRODUCTION_DB_ON_PREVIEW: ${{ vars.USE_PRODUCTION_DB_ON_PREVIEW }}
      DURABLE_OBJECT_NAME: ${{ vars.DURABLE_OBJECT_NAME }}
      DURABLE_OBJECT_CLASS: ${{ vars.DURABLE_OBJECT_CLASS }}
      DURABLE_OBJECT_MIGRATION_TAG: ${{ vars.DURABLE_OBJECT_MIGRATION_TAG }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          persist-credentials: true

      - name: Verify src/index.js
        run: |
          [ -f "src/index.js" ] || (echo "Error: src/index.js missing" >&2; exit 1)

      - name: Install tools
        run: |
          npm install wrangler@4 --save-dev
          sudo apt update -qq && sudo apt install -y jq -qq

      - name: Determine Deploy Type & Badge Label
        id: cfg
        run: |
          sanitize() {
            echo "$1" \
              | tr '[:upper:]' '[:lower:]' \
              | tr '/' '-' \
              | sed 's/[^a-z0-9-]/-/g' \
              | sed 's/--*/-/g' \
              | sed 's/^-//;s/-$//'
          }
          BRANCH_REF="${{ github.ref }}"
          BRANCH_NAME=$(echo "$BRANCH_REF" | sed 's|^refs/heads/||' | sed 's|^refs/pull/[0-9]*/merge$||')
          EVENT="${{ github.event_name }}"
          BADGE_OVERRIDE="${{ inputs.badge_label }}"
          if [ "$EVENT" = "push" ] && [ "$BRANCH_NAME" = "main" ]; then
            echo "type=prod" >> $GITHUB_OUTPUT
            echo "env_name=" >> $GITHUB_OUTPUT
            echo "badge_label=production" >> $GITHUB_OUTPUT
          elif [ "$EVENT" = "pull_request" ]; then
            PR_NUM="${{ github.event.pull_request.number }}"
            ENV=$(sanitize "pr-${PR_NUM}")
            echo "type=pr" >> $GITHUB_OUTPUT
            echo "env_name=$ENV" >> $GITHUB_OUTPUT
            echo "badge_label=${BADGE_OVERRIDE:-$ENV}" >> $GITHUB_OUTPUT
          elif [ "$EVENT" = "workflow_dispatch" ]; then
            if [ "$BRANCH_NAME" = "main" ]; then
              echo "type=prod" >> $GITHUB_OUTPUT
              echo "env_name=" >> $GITHUB_OUTPUT
              echo "badge_label=production" >> $GITHUB_OUTPUT
            else
              ENV=$(sanitize "$BRANCH_NAME")
              echo "type=manual" >> $GITHUB_OUTPUT
              echo "env_name=$ENV" >> $GITHUB_OUTPUT
              echo "badge_label=${BADGE_OVERRIDE:-$ENV}" >> $GITHUB_OUTPUT
            fi
          else
            echo "type=skip" >> $GITHUB_OUTPUT
          fi

      - name: Validate Cloudflare credentials
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          echo "Validating Cloudflare API token..."
          npx wrangler whoami || { echo "Error: wrangler whoami failed." >&2; exit 1; }

      - name: Setup wrangler.toml with smart assets
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          [ -n "${{ steps.cfg.outputs.env_name }}" ] && FINAL_NAME="${{ steps.cfg.outputs.env_name }}-${{ env.WORKER_NAME }}" || FINAL_NAME="${{ env.WORKER_NAME }}"
          COMPAT_DATE=$(date +%Y-%m-%d)
          cat > wrangler.toml <<'BASE_EOF'
name = "${FINAL_NAME}"
main = "src/index.js"
compatibility_date = "${COMPAT_DATE}"
BASE_EOF
          CANDIDATES=("public" "dist" "build")
          FOUND=()
          for dir in "${CANDIDATES[@]}"; do
            [ -d "$dir" ] && FOUND+=("$dir")
          done
          if [ ${#FOUND[@]} -gt 1 ]; then
            echo "ERROR: Multiple asset dirs: ${FOUND[*]}" >&2
            exit 1
          elif [ ${#FOUND[@]} -eq 1 ]; then
            SELECTED="${FOUND[0]}"
            printf '\nassets = { directory = "%s" }\n' "$SELECTED" >> wrangler.toml
            echo "ASSETS_DIR=$SELECTED" >> $GITHUB_ENV
          fi
          echo "FINAL_WORKER_NAME=$FINAL_NAME" >> $GITHUB_ENV

      - name: Resolve Worker Host
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          cf_get() { curl -sS -X GET "https://api.cloudflare.com/client/v4/$1" -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" -H "Content-Type: application/json"; }
          DOMAIN_HOST=$(cf_get "accounts/$CLOUDFLARE_ACCOUNT_ID/workers/domains" | jq -r '.result[]?.hostname // empty' | head -n1 || true)
          [ -n "$DOMAIN_HOST" ] && DOMAIN_HOST=$(echo "$DOMAIN_HOST" | tr -d '[:space:]')
          BASE_NAME="${{ env.WORKER_NAME }}"
          if [ -n "$DOMAIN_HOST" ]; then
            [ -n "${{ steps.cfg.outputs.env_name }}" ] && HOST="${{ steps.cfg.outputs.env_name }}-${BASE_NAME}.preview.${DOMAIN_HOST}" || HOST="$DOMAIN_HOST"
          else
            SUBDOMAIN=$(cf_get "accounts/$CLOUDFLARE_ACCOUNT_ID/workers/subdomain" | jq -r '.result.subdomain // empty')
            [ -n "$SUBDOMAIN" ] || { echo "Error: no workers.dev subdomain" >&2; exit 1; }
            [ -n "${{ steps.cfg.outputs.env_name }}" ] && HOST="${{ steps.cfg.outputs.env_name }}-${BASE_NAME}.${SUBDOMAIN}.workers.dev" || HOST="${BASE_NAME}.${SUBDOMAIN}.workers.dev"
          fi
          PREVIEW_URL="https://$HOST"
          echo "WORKER_HOST=$HOST" >> $GITHUB_ENV
          echo "PREVIEW_URL=$PREVIEW_URL" >> $GITHUB_ENV

      - name: Create/Get D1 + Bind
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          DEPLOY_ENV="${{ steps.cfg.outputs.env_name }}"
          DB_NAME=$(if [ -z "$DEPLOY_ENV" ] || [ "$USE_PRODUCTION_DB_ON_PREVIEW" = "true" ]; then echo "$WORKER_NAME"; else echo "${DEPLOY_ENV}-${WORKER_NAME}"; fi)
          DB_ID=$(npx wrangler d1 list --json | jq -r --arg n "$DB_NAME" '.[] | select(.name == $n) | .uuid // empty')
          [ -z "$DB_ID" ] && npx wrangler d1 create "$DB_NAME" && DB_ID=$(npx wrangler d1 list --json | jq -r --arg n "$DB_NAME" '.[] | select(.name == $n) | .uuid')
          grep -q "database_id = \"$DB_ID\"" wrangler.toml || printf '\n[[d1_databases]]\nbinding = "%s"\ndatabase_name = "%s"\ndatabase_id = "%s"\n' "$BINDING_NAME" "$DB_NAME" "$DB_ID" >> wrangler.toml
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV

      - name: Apply Migrations
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in migrations/*.sql; do
            base=$(basename "$f")
            if [ "$base" = "migrations.sql" ]; then
              revision_exists=$(npx wrangler d1 execute "$DB_NAME" --command "SELECT COUNT(*) FROM pragma_table_info('matches') WHERE name = 'revision';" --remote --json | jq '.[0].results[0].cnt // 0')
              [ "$revision_exists" != "0" ] && continue
            fi
            npx wrangler d1 execute "$DB_NAME" --file="$f" --remote || exit 1
          done

      - name: Inject .cloudflare/vars.json into wrangler.toml
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          VARS_JSON=".cloudflare/vars.json"
          TOML="wrangler.toml"
          [[ ! -f "$VARS_JSON" ]] && exit 0
          jq empty "$VARS_JSON" >/dev/null 2>&1 || { echo "Error: invalid JSON in $VARS_JSON" >&2; exit 1; }
          sed -i '/^# --- BEGIN INJECTED VARS ---$/,/^# --- END INJECTED VARS ---$/d' "$TOML" 2>/dev/null || true
          { echo "# --- BEGIN INJECTED VARS ---"; echo "[vars]"; jq -r 'to_entries[] | "\(.key) = \"\(.value | gsub("\""; "\\\""))\""' "$VARS_JSON"; echo "# --- END INJECTED VARS ---"; } >> "$TOML"

      - name: Add Durable Object config
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          DO_NAME="${{ env.DURABLE_OBJECT_NAME }}"
          DO_CLASS="${{ env.DURABLE_OBJECT_CLASS }}"
          DO_TAG="${{ env.DURABLE_OBJECT_MIGRATION_TAG }}"
          [ -z "$DO_CLASS" ] && { echo "Error: DURABLE_OBJECT_CLASS not set" >&2; exit 1; }
          printf '\n[[durable_objects.bindings]]\nname = "%s"\nclass_name = "%s"\n\n[[migrations]]\ntag = "%s"\nnew_sqlite_classes = ["%s"]\n' "$DO_NAME" "$DO_CLASS" "$DO_TAG" "$DO_CLASS" >> wrangler.toml

      - name: Deploy Worker
        if: steps.cfg.outputs.type != 'skip'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy

      - name: Comment on PR
        if: steps.cfg.outputs.type == 'pr'
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: ${{ github.event.pull_request.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `Preview: ${{ env.PREVIEW_URL }}`
            });

      - name: Update README Preview Badge
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          URL="${{ env.PREVIEW_URL }}"
          LABEL="${{ steps.cfg.outputs.badge_label }}"
          CLEAN_LABEL=$(echo "$LABEL" | tr -d '-')
          SHIELD_URL="https://img.shields.io/badge/preview-${CLEAN_LABEL}-purple?label=preview"
          BADGE="[![preview](${SHIELD_URL})](${URL})"
          START="<!-- PREVIEW_BADGE_START -->"
          END="<!-- PREVIEW_BADGE_END -->"
          FILE="README.md"
          grep -qF "$START" "$FILE" && grep -qF "$END" "$FILE" || { echo "Error: missing badge markers" >&2; exit 1; }
          ESCAPED_START=$(printf '%s\n' "$START" | sed 's/[&/\]/\\&/g')
          ESCAPED_END=$(printf '%s\n' "$END" | sed 's/[&/\]/\\&/g')
          ESCAPED_BADGE=$(printf '%s\n' "$BADGE" | sed 's/[&/\]/\\&/g')
          cp "$FILE" "$FILE.tmp"
          sed -i "s|${ESCAPED_START}.*${ESCAPED_END}|${ESCAPED_START}${ESCAPED_BADGE}${ESCAPED_END}|" "$FILE.tmp"
          cmp -s "$FILE" "$FILE.tmp" && rm "$FILE.tmp" || mv "$FILE.tmp" "$FILE"

      - name: Commit README Update
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          git diff --quiet README.md && exit 0
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
            git add README.md
            git commit -m "docs: update preview badge for ${{ steps.cfg.outputs.badge_label }}"
            git push origin HEAD:refs/heads/$BRANCH_NAME --force
          else
            git add README.md
            git commit -m "docs: update preview badge for ${{ steps.cfg.outputs.badge_label }}"
            git push
          fi
