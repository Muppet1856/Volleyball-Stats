name: Deploy & Update Preview Comment

on:
  push:
    branches: [ main, partition ]
#    branches: '**'
    paths-ignore: [ '**/.github/**', '**/README.md' ]
  pull_request:
    types: [ opened, synchronize ]
    paths-ignore: [ '**/.github/**', '**/README.md' ]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-and-badge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      WORKER_NAME: ${{ vars.WORKER_NAME }}
      BINDING_NAME: ${{ vars.BINDING_NAME }}
      USE_PRODUCTION_DB_ON_PREVIEW: ${{ vars.USE_PRODUCTION_DB_ON_PREVIEW }}

    steps:
      # ————————————————————————
      # Checkout
      # ————————————————————————
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          persist-credentials: true

      # ————————————————————————
      # Verify that the entry point is available
      # ————————————————————————
      - name: Verify src/index.ts
        run: |
          [ -f "src/index.ts" ] || (echo "Error: src/index.ts missing" >&2; exit 1)

      # ————————————————————————
      # Install Tools
      # ————————————————————————
      - name: Install tools
        run: |
          npm install wrangler@4 --save-dev
          sudo apt update -qq && sudo apt install -y jq -qq

      # ————————————————————————
      # Determine Deploy Type
      # ————————————————————————
      - name: Determine Deploy Type
        id: cfg
        run: |
          sanitize() {
            echo "$1" \
              | tr '[:upper:]' '[:lower:]' \
              | tr '/' '-' \
              | sed 's/[^a-z0-9-]/-/g' \
              | sed 's/--*/-/g' \
              | sed 's/^-//;s/-$//'
          }

          BRANCH_REF="${{ github.ref }}"
          BRANCH_NAME=$(echo "$BRANCH_REF" | sed 's|^refs/heads/||' | sed 's|^refs/pull/[0-9]*/merge$||')
          EVENT="${{ github.event_name }}"

          if [ "$EVENT" = "push" ]; then
            if [ "$BRANCH_NAME" = "main" ]; then
              echo "type=prod" >> $GITHUB_OUTPUT
              echo "env_name=" >> $GITHUB_OUTPUT
            else
              ENV=$(sanitize "$BRANCH_NAME")
              # Check if this branch has an open PR (to avoid duplicate runs with pull_request trigger)
              API_URL="https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:${BRANCH_NAME}&state=open"
              PR_COUNT=$(curl -s -H "Authorization: token ${{ github.token }}" -H "Accept: application/vnd.github.v3+json" "$API_URL" | jq 'length')
              if [ "$PR_COUNT" -gt 0 ]; then
                echo "type=skip" >> $GITHUB_OUTPUT
                echo "Skipping push deployment for branch $BRANCH_NAME (open PR exists; handled by pull_request trigger)"
              else
                echo "type=branch" >> $GITHUB_OUTPUT
                echo "env_name=$ENV" >> $GITHUB_OUTPUT
              fi
            fi

          elif [ "$EVENT" = "pull_request" ]; then
            PR_NUM="${{ github.event.pull_request.number }}"
            ENV=$(sanitize "pr-${PR_NUM}")
            echo "type=pr" >> $GITHUB_OUTPUT
            echo "env_name=$ENV" >> $GITHUB_OUTPUT

          elif [ "$EVENT" = "workflow_dispatch" ]; then
            if [ "$BRANCH_NAME" = "main" ]; then
              echo "type=prod" >> $GITHUB_OUTPUT
              echo "env_name=" >> $GITHUB_OUTPUT
            else
              ENV=$(sanitize "$BRANCH_NAME")
              echo "type=manual" >> $GITHUB_OUTPUT
              echo "env_name=$ENV" >> $GITHUB_OUTPUT
            fi

          else
            echo "type=skip" >> $GITHUB_OUTPUT
          fi

      # ————————————————————————
      # Validate Cloudflare credentials early
      # ————————————————————————
      - name: Validate Cloudflare credentials
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail
          echo "Validating Cloudflare API token..."
          npx wrangler whoami || {
            echo "Error: wrangler whoami failed. Check CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID." >&2
            exit 1
          }

      # ————————————————————————
      # Setup wrangler.toml + Smart Assets Detection
      # ————————————————————————
      - name: Setup wrangler.toml with smart assets
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail

          if [ -n "${{ steps.cfg.outputs.env_name }}" ]; then
            # When previews intentionally share the production database, point them at the
            # production Worker script name so Cloudflare reuses the same Durable Object.
            if [ "${{ env.USE_PRODUCTION_DB_ON_PREVIEW }}" = "true" ]; then
              FINAL_NAME="${{ env.WORKER_NAME }}"
            else
              FINAL_NAME="${{ steps.cfg.outputs.env_name }}-${{ env.WORKER_NAME }}"
            fi
          else
            FINAL_NAME="${{ env.WORKER_NAME }}"
          fi
          COMPAT_DATE=$(date +%Y-%m-%d)

          echo "name = \"${FINAL_NAME}\"" > wrangler.toml
          echo "main = \"src/index.ts\"" >> wrangler.toml
          echo "compatibility_date = \"${COMPAT_DATE}\"" >> wrangler.toml

          {
            echo "" >> wrangler.toml
            echo "[durable_objects]" >> wrangler.toml
            echo "bindings = [" >> wrangler.toml
            echo "  { name = \"${FINAL_NAME}\", class_name = \"MatchState\" }" >> wrangler.toml
            echo "]" >> wrangler.toml
            echo "" >> wrangler.toml
            echo "[[migrations]]" >> wrangler.toml
            echo "tag = \"v1\"" >> wrangler.toml
            echo "new_sqlite_classes = [ \"MatchState\" ]" >> wrangler.toml
          }

          # ——— Detect assets: public → dist → build (only ONE allowed) ———
          CANDIDATES=("public" "dist" "build")
          FOUND=()
          SELECTED=""

          for dir in "${CANDIDATES[@]}"; do
            if [ -d "$dir" ]; then
              FOUND+=("$dir")
            fi
          done

          if [ ${#FOUND[@]} -gt 1 ]; then
            echo "ERROR: Multiple asset directories found: ${FOUND[*]}" >&2
            echo "Only one of 'public', 'dist', or 'build' is allowed." >&2
            echo "Remove or rename the extras." >&2
            exit 1
          elif [ ${#FOUND[@]} -eq 1 ]; then
            SELECTED="${FOUND[0]}"
            echo "[assets]" >> wrangler.toml
            echo "directory = \"$SELECTED\"" >> wrangler.toml
            echo "binding = \"ASSETS\"" >> wrangler.toml
            echo "Using assets directory: $SELECTED"
          else
            echo "No assets directory found (public/dist/build) – skipping assets binding."
          fi

          echo "FINAL_WORKER_NAME=$FINAL_NAME" >> $GITHUB_ENV
          if [ -n "$SELECTED" ]; then
            echo "ASSETS_DIR=$SELECTED" >> $GITHUB_ENV
          fi          

      # ————————————————————————
      # Resolve Worker Host
      # ————————————————————————
      - name: Resolve Worker Host
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail

          cf_get() {
            local path="$1"
            curl -sS -X GET "https://api.cloudflare.com/client/v4/${path}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json"
          }

          # Always fetch the workers.dev subdomain
          SUB_JSON=$(cf_get "accounts/${CLOUDFLARE_ACCOUNT_ID}/workers/subdomain")
          SUBDOMAIN=$(echo "$SUB_JSON" | jq -r '.result.subdomain // empty')
          [ -n "$SUBDOMAIN" ] || { echo "Error: cannot get workers.dev subdomain" >&2; exit 1; }

          # Fetch custom domain (if any)
          DOMAIN_HOST=""
          DOMAINS_JSON=$(cf_get "accounts/${CLOUDFLARE_ACCOUNT_ID}/workers/domains")
          DOMAIN_HOST=$(echo "$DOMAINS_JSON" | jq -r '.result[]? | select(.hostname != null and .hostname != "") | .hostname' | head -n1 || true)

          if [ -n "$DOMAIN_HOST" ]; then
            DOMAIN_HOST=$(echo "$DOMAIN_HOST" | tr -d '[:space:]')
            echo "Custom domain found: $DOMAIN_HOST"
          else
            echo "No custom domain found – using workers.dev for all"
          fi

          BASE_NAME="${{ env.WORKER_NAME }}"

          # For previews: Always use workers.dev
          if [ -n "${{ steps.cfg.outputs.env_name }}" ]; then
            HOST="${{ steps.cfg.outputs.env_name }}-${BASE_NAME}.${SUBDOMAIN}.workers.dev"
          
          # For production: Use custom domain if available, else workers.dev
          else
            if [ -n "$DOMAIN_HOST" ]; then
              HOST="${DOMAIN_HOST}"
            else
              HOST="${BASE_NAME}.${SUBDOMAIN}.workers.dev"
            fi
          fi

          PREVIEW_URL="https://$HOST"
          echo "WORKER_HOST=$HOST" >> $GITHUB_ENV
          echo "PREVIEW_URL=$PREVIEW_URL" >> $GITHUB_ENV
          echo "Resolved host: $HOST"

      # ————————————————————————
      # D1: Create / Bind
      # ————————————————————————
      - name: Create/Get D1 + Bind
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail

          DEPLOY_ENV="${{ steps.cfg.outputs.env_name }}"
          DB_NAME=$(if [ -z "$DEPLOY_ENV" ] || [ "$USE_PRODUCTION_DB_ON_PREVIEW" = "true" ]; then
            echo "$WORKER_NAME"
          else
            echo "${DEPLOY_ENV}-${WORKER_NAME}"
          fi)

          DB_ID=$(npx wrangler d1 list --json | jq -r --arg n "$DB_NAME" '.[] | select(.name == $n) | .uuid // empty')

          if [ -z "$DB_ID" ]; then
            npx wrangler d1 create "$DB_NAME"
            DB_ID=$(npx wrangler d1 list --json | jq -r --arg n "$DB_NAME" '.[] | select(.name == $n) | .uuid')
          fi

          if ! grep -q "database_id = \"$DB_ID\"" wrangler.toml; then
            cat >> wrangler.toml <<EOF

          [[d1_databases]]
          binding = "$BINDING_NAME"
          database_name = "$DB_NAME"
          database_id = "$DB_ID"
          EOF
          fi

          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV

      # ————————————————————————
      # Apply Migrations
      # ————————————————————————
      - name: Apply Migrations
        if: steps.cfg.outputs.type != 'skip'
        run: |
          FINAL_NAME="${{ env.FINAL_WORKER_NAME }}"
          npx wrangler d1 migrations apply $FINAL_NAME --remote

      # ————————————————————————
      # Load env vars from cloudflare/vars.json → wrangler.toml
      # ————————————————————————
      - name: Inject cloudflare/vars.json into wrangler.toml
        if: steps.cfg.outputs.type != 'skip'
        run: |
          set -euo pipefail

          VARS_JSON="cloudflare/vars.json"
          TOML="wrangler.toml"

          # -----------------------------------------------------------------
          # 1. Bail out early if the file does not exist
          # -----------------------------------------------------------------
          if [[ ! -f "$VARS_JSON" ]]; then
            echo "No $VARS_JSON found – nothing to inject."
            exit 0
          fi

          # -----------------------------------------------------------------
          # 2. Validate JSON
          # -----------------------------------------------------------------
          if ! jq empty "$VARS_JSON" >/dev/null 2>&1; then
            echo "Error: $VARS_JSON contains invalid JSON" >&2
            exit 1
          fi

          # -----------------------------------------------------------------
          # 3. Append the new block
          # -----------------------------------------------------------------
          {
            echo "[vars]"
            # Quote every value and escape inner quotes
            jq -r 'to_entries[] |
                   "\(.key) = \"\(.value | gsub("\""; "\\\""))\""' "$VARS_JSON"
          } >> "$TOML"

          COUNT=$(jq 'keys | length' "$VARS_JSON")
          echo "Injected $COUNT variable(s) from $VARS_JSON into $TOML"
          
      # ————————————————————————
      # Deploy Worker
      # ————————————————————————
      - name: Deploy Worker
        if: steps.cfg.outputs.type != 'skip'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy ${{ steps.vars.outputs.var_flags }}

      # ————————————————————————
      # Comment on PR
      # ————————————————————————
      - name: Comment on PR
        if: steps.cfg.outputs.type == 'pr'
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: ${{ github.event.pull_request.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `Preview: ${{ env.PREVIEW_URL }}`
            });

      # ————————————————————————
      # Pushover Notce
      # ————————————————————————
      - name: Send Pushover Notification
        if: always()  # Ensures this runs even if previous steps fail
        env:
          PO_USER_TOKEN: ${{ secrets.PO_USER_TOKEN }}
          PO_TOKEN: ${{ secrets.PO_TOKEN }}
          REPO_NAME: ${{ github.repository }}
          BRANCH_NAME: ${{ github.ref_name }}
          OUTCOME: ${{ job.status }}
        run: |
          cat << 'EOF' > pushover.sh
          #!/bin/bash

          # Script: pushover
          VERSION="1.0.0"
          # Description: Sends a formatted message via Pushover with optional title, sound, priority, and image.

          USER_TOKEN="$PO_USER_TOKEN"
          TOKEN="$PO_TOKEN"

          if [[ "$1" == "--version" ]]; then
            echo "pushover version $VERSION"
            exit 0
          fi

          if [[ "$1" == "--help" ]]; then
            cat <<EOD
          Usage:
            $0 "<message>" [options]

          Required:
            "<message>"            The message body to send (quoted)

          Optional:
            --title=TITLE          Notification title (defaults to hostname)
            --image=FILE           Attach an image file
            --sound=SOUND          Notification sound
            --priority=LEVEL       Priority level: -1 (quiet), 0 (normal), 1 (high)
            --quiet                Suppress local command output
          EOD
            exit 0
          fi

          if [[ -z "$1" || "$1" == --* ]]; then
            echo "Error: Message is required as the first argument."
            exit 1
          fi

          message="$1"
          title="$(hostname)"
          sound=""
          priority=""
          image_path=""
          quiet=0

          for arg in "${@:2}"; do
            case $arg in
              --title=*)
                title="${arg#--title=}"
                title=$(echo -n "$title" | head -c 1024)
                ;;
              --image=*)
                image_path="${arg#--image=}"
                ;;
              --sound=*)
                sound="${arg#--sound=}"
                ;;
              --priority=*)
                priority="${arg#--priority=}"
                ;;
              --quiet)
                quiet=1
                ;;
              *)
                echo "Error: Unrecognized option '$arg'"
                exit 1
                ;;
            esac
          done

          message=$(echo -n "$message" | head -c 1024)

          curl_args=(
            --form-string "token=$TOKEN"
            --form-string "user=$USER_TOKEN"
            --form-string "message=$message"
            --form-string "title=$title"
            --form-string "html=1"
          )

          valid_sounds=(pushover bike bugle cashregister classical cosmic falling gamelan incoming intermission magic mechanical piano-bar siren spacealarm tugboat alien climb persistent echo updown none tada scott espn)
          if [[ -n "$sound" ]]; then
            if [[ ! " ${valid_sounds[*]} " =~ " $sound " ]]; then
              echo "Invalid sound: '$sound'. Must be one of: ${valid_sounds[*]}" >&2
              exit 1
            fi
            curl_args+=( --form-string "sound=$sound" )
          fi

          valid_priorities=(-1 0 1)
          if [[ -n "$priority" ]]; then
            if [[ ! " ${valid_priorities[*]} " =~ " $priority " ]]; then
              echo "Invalid priority: '$priority'. Must be one of: ${valid_priorities[*]}" >&2
              exit 1
            fi
            curl_args+=( --form-string "priority=$priority" )
          fi

          if [[ -n "$image_path" && -f "$image_path" ]]; then
            curl_args+=( -F "attachment=@$image_path" )
          fi

          curl "${curl_args[@]}" https://api.pushover.net/1/messages.json &> /dev/null
          EOF
          
          chmod +x pushover.sh
          
          # Example usage: Send a message when the workflow is done
          ./pushover.sh "Deploy action $OUTCOME" --title="$REPO_NAME:$BRANCH_NAME" --priority=0 --image="http://<https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png"